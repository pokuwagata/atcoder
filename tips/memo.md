# memo

## 目標

- 2020/8 ぐらいに茶色になれると嬉しい

## やること

- A,B の安定化
  - 大体対応できているが、素早く・正確に
    - 標準ライブラリの活用
    - AOJ ITP1 埋める
    - A, B の過去問を解く
- C 慣れ
  - [分野別初中級者が解くべき過去問精選-100-問](https://qiita.com/e869120/items/eb50fdaece12be418faa#2-3-%E5%88%86%E9%87%8E%E5%88%A5%E5%88%9D%E4%B8%AD%E7%B4%9A%E8%80%85%E3%81%8C%E8%A7%A3%E3%81%8F%E3%81%B9%E3%81%8D%E9%81%8E%E5%8E%BB%E5%95%8F%E7%B2%BE%E9%81%B8-100-%E5%95%8F)
  - 3 個のデータ構造の例題を解く

## AOJ

- `<<endl` で改行挿入できる
- pow は double を返す、#include cmath 必要
- cin, cout は scanf, printf でも代用できる
- scanf の第一引数は受け取る文字列を表現する
- **swap は`<algorithm>`header**
  - &は不要
- sort の素朴な実装は勝ち抜き戦（O(n!))
- scanf で変数のリファレンス忘れがち
- printf で\n 忘れがち
- 長さ不定の入力の場合は while と if で受ける
  - while は for 文の終了条件を省略しても実現できる。index が必要な場合はこっちの方がいい
- int → double への cast は C-style で良さそう
  - <https://stackoverflow.com/questions/28002/regular-cast-vs-static-cast-vs-dynamic-cast>
- 円周率は<math.h>の M_PI にある
- ""と''は意味が違う？
  - <https://stackoverflow.com/questions/3683602/single-quotes-vs-double-quotes-in-c-or-c>
  - ""文字列リテラルは char の配列で\0 で終端する、配列は式の中では配列の先頭要素へのポインタに読み替えられる
    - 添字演算子`[]`は配列と無関係、`array[i]`は array がポインタに読み替えられて\*(p+i)になるだけ
- c/c++には switch 文がある
- **`<alghorihm>`で max, min 関数使える**
- 最大・最小を求めるのは、初期値に必ず負ける数を設定しておいて for 文で変数を更新しながら勝ち抜き戦すると手軽
- 合計を保持する際には型に注意する。long int 2^31 -1, long long 2^63 -1
- 大抵は long int と int に差はなく 4byte(32bit)（処理系依存ではある）
  - <https://www.quora.com/Whats-the-difference-between-int-type-and-long-int-type-in-C++>
- 偶数かつ偶数=true || 奇数かつ奇数=true 　<=> 和が偶数 を利用してこういう模様を作れる

```
4 4
#.#.
.#.#
#.#.
.#.#
```

- do{} while(); は最初に 1 度処理を実行する
- for 文で最後のループだけ別の処理をしたい場合は、手前までループして次の処理で if 文にしてしまうのもあり
  - 例) '1 2 3'のように最後だけ右にスペースをつけない処理等
  - もしくは`cout <<" "<< n[num-i-1]`
- `if(!true)`書ける
- `#include<map>` `map<char,int>ll;`で map 型使える
- サイズ固定の多次元配列の初期化 `int arr[10][20] = {0};`, `memset(arr, 0, sizeof arr);`
  - <https://stackoverflow.com/questions/23039134/how-to-use-memset-function-in-two-dimensional-array-for-initialization-of-member>
- `scanf("%s %d",mark,&tmp);` はアドレス演算子の返す型がポインタで、配列は式の中でポインタに読み替えられるので OK
- 代入文は並べられる`S[i] = H[i] = C[i] = D[i] = 0;`
- `vector<vector<int>>`の>>は c++11 以降じゃないとエラーになる。g++はオプションを指定することでコンパイル時のバージョンサポートを
  変更できる
  - <https://www.neuralsparrow.com/entry/2017/04/12/002201>
- `1 2 3`のような入力は cin >> で受けたほうが楽、`scanf`だと無理？

```
timeout: the monitored command dumped core 0.00user 0.00system 0:00.00elapsed 66%CPU (0avgtext+0avgdata 3184maxresident)k 0inputs+16outputs (0major+236minor)pagefaults 0swaps
```

- vector を使うと ↑ のエラーが出るみたい。できるだけ配列を使ったほうがいい

- `int a[n][m] = {0};`動的配列の初期化は無理ぽい
- 配列は初期化せずに加算等を行うと意図しない結果になる
- ITP1_6_D はなぜ不正解なのかよく分からない...
- `while`の中で`scanf`と`printf`すると、実行時は 1 入力に対して出力後に次の入力を待つように見えるが実際には入力を全て受けてから全て出力するので問題ない
- `scanf("%d")`のループで`1 2 3`を受け取ることは可能
- 入力の matrix に対して加工・行列追加等を行って出力する場合は、読み込みと出力を分離したほうがすっきりするかも（別の二次元配列を出力用に用意する）
  - ITP1-7
- 出力値が変な場合は`printf`に表示したい変数を渡し忘れていないか確認する
  - `printf("%d")`等
- 32bit int は −2,147,483,648 から 2,147,483,647 桁数は 10 桁
- 64bit long long int は最大が 9223372036854775807, 桁数は 19 桁
- long long int は`printf("%lld", hoge)`
- `(int)num[0]`で 5 が 53 になるのはなぜなんだろう？
  - `ch -0`で int にキャストできる
- 終端文字までのループは`while((ch = getchar()) != '\n')`
  - 改行文字を含む場合は EOF で判定
- 大文字 → 小文字変換は、`ch + 32`
- アルファベット判定は`ch >= 'a' && ch <= 'z'`
- `<bits/stdc++.h>` は何？
  - <https://stackoverflow.com/questions/25311011/how-does-include-bits-stdc-h-work-in-c>
- `cout << (ok ? "a" : "b") << endl;` のように、`<<` が続く場合の 3 項演算子は括弧で囲う
- string を小文字に変換する `transform(t.begin(), t.end(), t.begin(), ::tolower);`
- 入力をある条件まで受け続ける `while(cin>>s,s!="END_OF_TEXT"){`
- string は `<` で比較可能（ASCII コード）
- switch は整数型か列挙型じゃないとだめ
- `func(a++, b--)` のように引数では ++ 等は効かない。`func(a+1, b-1)` なら OK おそらく式として評価された値が元のまま？
- `string&` 型は string のアドレスの型らしい
- `str.replace` の引数に任意の開始点と終了点を与えるには、`str.begin()+a` のようにしてやる
  - `reverce` も同様。
- `substr(l, r)` は始点と終了点ではなく、始点 l からの相対位置 r であるため、文字列全体の 2~4 文字目を切り出す等の場合には注意が必要
  - r には 終了文字目 - l + 1 してあげると、終了文字目を含んで切り出せる
- float vs double
  - 32bit , 64bit の違い（単精度・倍精度）
    - 64bit の場合は 2^53-1 が最大値
- 個数が分かっているなら思考停止で vector 型使わなくても配列を使った方がいい
  - `cin >> x[i]` の形で受け取れる、

## 精選 100 問

- for 文で次の繰り返しに飛ぶのは break ではなく continue
- 1 以上の整数に対してループするときは、 rep (i=0) より素直に for 文(i=1;) 書いたほうが良さそう
- 詰まったらとにかくデバッガ動かす
- ある条件を満たす最大の部分文字列の長さを求めるなら、先頭から順に判定していって、条件を満たさなければカウントリセット
  - 2 重ループする必要ない
- `substr(l, r)` は l+r-1 番目まで切り出す。`substr(0,1)` は 1 文字目、`substr(1,1)` は 2 文字目を返す
  - (0, 0), (1, 1) は空文字を返す

## 3/21 AGC

- 動的な char 型の多次元配列の受け取り方
  - `scanf("%s", &m[i][0])`はどういう意味？ そもそも正しい？
- ↑ の関数への渡し方
- 多次元配列の長さの求め方
- grid 系問題を解いたことない
- A, B 問題を読んだが、問題が抽象化されていて正しく意図を理解できない、

## 3/28 ABC160

- int, long long int の 10 進数の最大桁数は把握した方が良さそう
- 多次元配列をどう関数へ渡したらいい？ 宣言は`int *dist[],`でいいみたい。実行時は？
- C99 では、func(int n, dist[][n])でいける, C++では駄目っぽい
  - 関数の仮引数における[]は最外周の配列に限りポインタに読み替えられる
  - dist[n][n] の型は int の配列(n)の配列(n)
  - 式中の dist は int の配列(n)のポインタ
- `1<<n`はビットシフトを表しているらしい
- 巡回セールスマン問題と bit DP は未経験
  - <https://qiita.com/drken/items/7c6ff2aa4d8fce1c9361#0-%E3%83%93%E3%83%83%E3%83%88%E3%81%A8%E3%81%AF>
  - しかし、C 問題については方法の適用以前に素朴な解決策があった
- acc でコンテストのテストデータ落とせないのはなぜ？

c

- `vector<int> a[n]` ではなく `vector<int> a(n)`
- 円環は 2 週目を元に、座標を振ることで区間を自然に計算できる

d

- 最短路を求めるアルゴリズムの整理
  - <https://www.youtube.com/watch?v=zG1L4vYuGrg&t=4281s>
- コスト 1 なら BFS
- グラフを二次元配列で持つと、やはり作成が辛い

## 4/4 ABC161

### a

- `iostream` or `<algorithm>` で `swap` が使える
  - `swap(a, c);` で、変数や配列の要素同士を入れ替えることができる

### b

- int 型同士の割り算の商が int に丸められることに気づくのが遅すぎた
  - (double) でキャストすればいい
  - もしくは等式を変形して割り算が発生しないようにする
  - C++の暗黙的キャストのルールを知らない

### c

- 良かったこと
  - 紙を使えた、図を書けた
  - 余りを利用することに気づけたこと
  - エッジケース（多分）以外は正解していた
- 改善点
  - 1 % 3 が 1 だと知らなかった。つまり剰余の結果が分子になる
    - なので分子・分母の大小で場合分けして複雑に考えてしまった
  - 既に定義済みの関数の再実装で思考コストを削られていた感ある
    - `#include <iostream>` で `abs` が使える
    - `<algorithm>` で `min` が使える
  - 愚直に `n>k`, `n=k`, `n<k` で場合分けして検討した方が良かった
  - 剰余の値だから int で十分というのは勘違い
    - 分子が long long なら剰余だって long long になる
    - 答えの出力に %d を使っていたので long long が正しく扱われなかった
      - cout だったらそういうことに気を使わなくていいので楽
  - テストケースとして、各値が最小の場合と最大の場合ぐらいは検討してもいいんじゃないか

### d

- 入力値が最大の場合に、何ステップの計算が発生するか？　 10^8 / 秒 ステップとすると、2 秒以内にしないといけない
  - 3\*10^9 のループ\*探索 は絶対に間に合わない
  - <https://cppx.hatenablog.com/entry/2017/08/06/104144>
  - <https://atcoder.jp/contests/apg4b/tasks/APG4b_w?lang=ja>
- 愚直な全列挙で対処できないことを知った上で、どう取り組むか？
  - 性質に着目、桁ごとに分析する
  - 配列 (stack) を桁ごとに洗替(swap)、k 番目とサイズを比較して参照、k からサイズを引く... という実装がトリッキーに思えた

### 解説動画

- もっと c++ の機能を使っていってもいいかも
  - `vector` , `cin`, `cout`, `<bits/stdc++.h>`
- やはり `rep` は使ったほうが良いかも

## ABC162

a 問題

- 123 のような数値を文字列として扱えるかどうか不安だった
- 実は `s.find(1) != string::noop` で含むかどうか判定可能

b 問題

- 条件の変形に不安があった
  - ベン図が有効そう

c 問題

- 良かったこと
  - AC した
- 改善したいこと
  - 解答に時間がかかりすぎた
    - 最大公約数を求めるアルゴリズムを知らなかったので検索した
    - 最大公約数を求めるコストを勝手に高く見積もって、愚直に実装して AC することを目指さなかった
- gcd について
  - 小さい方の数（割る数を n として）計算量は O (log n)
    - 説明 1) ラメの定理により 最悪でも n の桁数 d の 5 倍で操作回数を抑えられるとすると
      n から桁数 d を求める操作(関数)を log10 n + 1 = O (log n) とできる　（ビッグオーの定義より）
    - 説明 2) b % (a%b) が b/2 以下になること利用して
      - 操作 2 回で 1/2 以下になるので、操作回数は 2 \* log2 b = O(log n)
      - 最悪でも 操作回数 k に対して n = 2^(k-1) が言えるので 操作回数は log2 2^(k-1) = O(log n) (ビッグオー記法の定義より)
      - b/2 以下になるのはなぜか？　直感的にはわかりにくい（証明は可能だが理解しにくい）
  - 参考
    - <https://blog.pixela.co.jp/2017/11/16/%E3%83%A6%E3%83%BC%E3%82%AF%E3%83%AA%E3%83%83%E3%83%89%E3%81%AE%E4%BA%92%E9%99%A4%E6%B3%95/>
    - <https://ja.wikipedia.org/wiki/%E3%83%A6%E3%83%BC%E3%82%AF%E3%83%AA%E3%83%83%E3%83%89%E3%81%AE%E4%BA%92%E9%99%A4%E6%B3%95#%E8%A8%88%E7%AE%97%E9%87%8F>
- 最大公約数について
  - 対象の数を構成する素数とその累乗を軸にとったとき、ある数 a, b で共有する領域の右上(最大の数)が最大公約数　（解説放送の 1:16:32 あたり）

d 問題

- 良かったこと
  - ひとまず実装したロジックは正しそう
- 改善したいこと
  - TLE を回避する方法が分からなかった。アルゴリズムの知識不足?
    - （解説を読んで）この問題については単なる考察不足だった
    - Not equal なら equal の場合を考えて、全体の集合から引けばいい
    - 条件が 2 つあったら、1 つだけを満たす場合を考える等、条件を変形・制限して考察する考え方が必要
    - O(N^3) に対して 2 変数から 3 変数目を導ければ O(N^2) にできるという考え方も足りてない

## ABC163

- b で提出言語選択ミス　かつ　変数名を間違えて分岐に設定していた
- c は内容理解が面倒で、整理したら簡単だった
- d は純粋に知識・経験不足。仕方ない、個数の mod を取る意味が理解できなかった
  - mod について
    - <https://ikatakos.com/pot/programming_algorithm/number_theory/mod_combination>
    - <https://drken1215.hatenablog.com/entry/2018/06/08/210000>
    - mint を定義しておくと楽らしい
      - <https://github.com/atcoder-live/library/blob/master/mint.cpp>

## ABC159

- a は string なので 全て共通であることを変に抽象化しないで、== "AAA" で良かった
- b は `n * a / (a+b)` でオーバーフローする、`a * (n/(a+b))` 等式変形して評価結果毎に注意？

### 解説放送

a

- pi は acos(-1) でいける

c

- `ans[n-1] += 1;` は `ans[n-1]++` でもいい
- `vector` を使っていると、`for(int x : ans)` のように書ける

d

- 二項定理を活用するほどの問題ではなかった
- 任意の個数を選ぶ場合に、最小値と最大値から構成しうる和の個数を求められるという、整数の性質が自明じゃなかった

## ABC164

- a, b, c は素直に実装できた
- d はロジックは分かるが、大きいデータの取り扱いが分からず解答に至らなかった
  - 入力サイズの大きさを正確に把握していなかったので 3 回 RE してしまった
  - なぜ `(int)string.size()` のように提出時にキャストが必要なのかは疑問

### 解説放送

- b
  - 愚直にシミュレーションしたが、実際には除算の結果を切り上げれば OK
    - (a + (b-1)) / b の結果を切り捨てれば a / b の結果の切り上げになる
      - <https://daeudaeu.com/programming/c-language/kurisuke_kiriage_shisyagonyu/>
      - 整数の割り算の結果の結果は、1/b 単位で変化し、小数部が0以外の場合に最小の値が 1/b だから b-1/b すれば必ず整数部が1上がる（繰り上がる）
    - なぜ ceil では駄目？ 浮動小数点の誤差が影響する可能性
    - ただの除算は結果を切り捨てすることを忘れない
- d
  - 累積和、逆元を知らないと無理
    - <https://qiita.com/drken/items/56a6b68edef8fc605821>
  - 整数→数列→累積和→累積和が2019の倍数＝mod 2019 の場合に満たす関係式→累積和を順に調査（O(n)）

## ABC166

- b
  - vector 型の宣言に迷った
  - 0 index と 入力の対応をミスりかけた
- c
  - どういうデータ構造がベストなのかよく分からなかったので手探り感があった
    - もう少し C++ の STL を実際に使って慣れたほうが良さそう
  - こちらも 0 index と入力の対応ミスをデバッグしてた
  - 二重for文内で continue を使った場合の挙動を誤解していた（すぐ気づいたが breakが正しい）
  - `<=` と`<` の間違い、問題文の解釈・論理否定
    - ある集合の中に、ある値より大きいものが存在しないことを判定したいとき、どうコードに落とすとベストか？
      - 言い換えると、全ての要素が、ある値以下であること
- d
  - 因数分解かと思ったが、いまいち別の問題に言い換えられなかった

### 解説放送

- c
  - あらかじめ条件を満たした集合を定義しておいて、入力に応じて集合から外していく方針もあり
- d
  - 実際のところ、それなりに少ない候補を全探索すればよいだけだった
  - a, b の上限を調べることが必要
    - 素因数分解→4乗でX→Xの最大値は10^9 なので A は 最大でも10^(2.5) くらい→ B も同じくらいを調査

## ABC165

### 解説放送

a

- b以下の最大の k の倍数は b/k * k で求まる（なぜ？）

b

- 複利の意味が少し不安だった。テストケースに最大のパターンが用意されていることに気づかなかったのでループの添字を ll にしてしまった
  - もし 2^63 -1 = 9.2 * 10^18 が答えになるなら、とても 2 sec では間に合わない

c

- グローバルスコープの場合、`a = b = c = d = vector<int>(q);` のように後で個数を決めて代入可能
- ある数列のサイズに達するまで再帰スタックを重ねる、サイズが満たされたら 判定＋インクリメント
- n, m が最大の場合にどれくらいの組み合わせを検証するか？　重複組合せを考える
  - <https://mathtrain.jp/tyohukuc>
  - 種類-1 個のしきりの配置場所問題
- c++ の vector はそのまま定義すると値渡し
  - 参照渡しの方が追加・削除を明示的に書く必要があるので分かりやすい... ように見えるがそうとも言えないかも

## ABC114

c

- 配列ではなく整数で DFS していく
  - 10x + 3, 10x + 7, ... の形で再帰関数の呼び出しを列挙するという発想
- 再帰の終了条件を整数で適宜設定しておく
- 全てが揃っているか等の判定はビットの論理和を使うと便利

## ABC167

a

- どう書けばいいのか分からなくて焦った

b

- 場合分けできたと思ったら出来てなかった

c

- めちゃくちゃ時間かかったが、DFS で AC 出来たので満足
- 二次元配列への格納は `rep(j,m) cin >> a[i][j];` で良い

### 解説放送

a

- 入力の制約をきちんと読もう。英小文字しか来ない
- 文字列を削る操作は .pop_back() 可能

b

- なんか巧妙、オリジナル実装でなぜ駄目かよく分からない

c

- なぜか組み合わせの総数を12個から重複ありで12個選ぶ組み合わせの数として評価していた
  - 実際には選ぶ-選ばないの組み合わせだけ
  - 部分集合 => bit で ループ回す

### 解説放送

d

- 解法1 循環を判定する
  - 到達頂点を記録し、同一の頂点に到達＝循環の発生とする
  - N 回遷移後の結果について、循環前の場合・循環後の場合に切り分けて判定を行う
- 解法2 ダブリング
  - 各頂点について、1, 2, 4, 8... 回遷移先のテーブルを作成する
  - N 回遷移後の結果について、↑のテーブルで既知の値の組み合わせで表現可能
  - 10^18 は 2進数で何桁か？
    - 10^3 ~= 2^10 = 1024 なので、約10桁で換算すると、18/3 *10= 60桁あればOK
- `ll d; 1 << D` はオーバフローするので `1ll<<D` と書かないといけない
- `int[1]` は `int[size]` なので size-1 個までしか参照できない
  - この場合の動作が Homebrew GCC 9.3.0 C++17 と GNU GCC 9.2.1 のAtCoder の実行環境で差異があるのかも？
    - というよりは AtCoder 上で実行されるテストケースによってあぶり出されているのかも
    - <https://atcoder.jp/contests/language-test-202001>

## ABC168

a, b

- かなりハイペースでAC

c

- double と int が混ざった四則演算の型ってどうなるんだっけ？
- 三角関数って C++ でどう使うんだっけ
- 教訓
  - 問題文をしっかり理解すること、各針が一定の角速度で動いている、としっかり書いている
  - 実装対象についてしっかりとイメージを持つこと、持てないなら画像検索でも動画でも何でも見る
  - pi = acos(-1) でおｋ
  - 精度指定なら printf が必要、cout は小数点以下6桁ぐらいで打ち止めになってしまう

d

- 方針は良さそうだったが、c で時間的にも体力的にも消耗していたので解答できず
- DFS と BFSを取り違えていた感ある

### 解説放送

d

- 隣接リスト＝頂点に隣接する頂点の集合　で持つ
- BFS = while ループ内でqueue に詰めていって処理、queue が空になったら終了が良い
- 各頂点の距離・親の頂点等の情報は素直に配列で持てばいい
- main 関数外（グローバルスコープ）で vector を宣言する場合はなぜ `vector<int> a[2]` の形じゃないと駄目なんだろう？
  - `vector<int>` 型の配列を宣言している模様
- queue のループの中で、親をベースに隣接リストから取り出した頂点に対して、距離・親の設定・queue へのpush を行う
- dist は -1 でも INF でもいいが、dist[0]=0 は宣言必要

### ABC159

c

- 相加相乗平均はすぐ思いついた、でも公式を見ても応用できると判断できなかった
  - 数学力が鈍っている気がする
- その後何となく整数が答えの方が数が大きくなるんだろうと仮定した、それは間違いだった
- 相加相乗平均の本質的な部分を理解しているかどうか、距離を互いに縮めると積が大きくなるという性質を分かっているか

d

- 何となく組み合わせを求める関数を書くのが無理だと思っていたが、別に nCk の k=2 で固定なら難しくもなんともない
- 計算量の見積もりはできていたようで出来ていなかった。ボールの数 * ボールの種類の分布毎に組み合わせを計算すると、最悪 O(N^2)
- 2重ループの計算量を抑えるためには、内側のループを、別の基準量から計算する等して回避する方法が良い
- 分布という形で配列を持つこと
  - a[i番という種類]=j個ある　のような形
- 分布と、i番目に何の種類があるかという配列を混同しない

### ABC167 復習

d

- `vector<int> d[60];` は `d[0][2] == 2` のようにすると `segmantation error`
  - おそらく vector のサイズを指定していない状態が原因
  - これは素直に `int d[60][20005]` のようにしておけばよい
- ダブリングの表を作るのは、以下のどちらでも正しい
  - `d[i][j] = d[i-1][d[i-1][j]];`
  - `d[i+1][j] = d[i][d[i][j]]`
  - 最大桁（この問題では index 59）まで格納するようなループにすること
    - パターン1 の場合は 終了条件は i<60 or i<=59
    - パターン2 の場合は i<59 or i<=58
- `ll l = 1ll << i;` で２進数を得るテクニック
- 最大桁から `l <=k` する必然性は別にない？

### ABC157

c

- 全探索可能なら、変にスマートに求めようとするより安定しそう

## ABS

- `3つのマスからなるマス目` というとき、マス目という言葉はマスの集合を指すらしい

## 環境設定

- `<bits/stdc++.h>` を使えるようにする
  - <https://qiita.com/EngTks/items/ffa2a7b4d264e7a052c6>
- `gcc` でコンパイルしても lldb でデバッグ可能なのか？
  - タスクを定義して試したら普通に動作したので問題ないっぽい
