# memo

## 目標

- 2020/8 ぐらいに茶色になれると嬉しい

## やること

- C, D 問題の対策
- D 中心で学習しているが、意外と C で躓くこともあるので練習した方がいいかも？
  - C はあんまり類題が出なそうで対策の費用対効果薄そうな印象もあるが...

## AOJ

- 円周率は<math.h>の M_PI にある

- 大文字 → 小文字変換は、`ch + 32`
- アルファベット判定は`ch >= 'a' && ch <= 'z'`
- `cout << (ok ? "a" : "b") << endl;` のように、`<<` が続く場合の 3 項演算子は括弧で囲う
- string を小文字に変換する `transform(t.begin(), t.end(), t.begin(), ::tolower);`
- `func(a++, b--)` のように引数では ++ 等は効かない。`func(a+1, b-1)` なら OK おそらく式として評価された値が元のまま？
- `str.replace` の引数に任意の開始点と終了点を与えるには、`str.begin()+a` のようにしてやる
  - `reverce` も同様。
- `substr(l, r)` は始点と終了点ではなく、始点 l からの相対位置 r であるため、文字列全体の 2~4 文字目を切り出す等の場合には注意が必要
  - r には 終了文字目 - l + 1 してあげると、終了文字目を含んで切り出せる
- float vs double
  - 32bit , 64bit の違い（単精度・倍精度）
    - 64bit の場合は 2^53-1 が最大値

## 精選 100 問

- 詰まったらとにかくデバッガ動かす
- ある条件を満たす最大の部分文字列の長さを求めるなら、先頭から順に判定していって、条件を満たさなければカウントリセット
  - 2 重ループする必要ない
- `substr(l, r)` は l+r-1 番目まで切り出す。`substr(0,1)` は 1 文字目、`substr(1,1)` は 2 文字目を返す
  - (0, 0), (1, 1) は空文字を返す

## 4/4 ABC161

### a

- `iostream` or `<algorithm>` で `swap` が使える
  - `swap(a, c);` で、変数や配列の要素同士を入れ替えることができる

### b

- int 型同士の割り算の商が int に丸められることに気づくのが遅すぎた
  - (double) でキャストすればいい
  - もしくは等式を変形して割り算が発生しないようにする
  - C++の暗黙的キャストのルールを知らない

## ABC162

a 問題

- 123 のような数値を文字列として扱えるかどうか不安だった
- 実は `s.find(1) != string::noop` で含むかどうか判定可能

c 問題

- 良かったこと
  - AC した
- 改善したいこと
  - 解答に時間がかかりすぎた
    - 最大公約数を求めるアルゴリズムを知らなかったので検索した
    - 最大公約数を求めるコストを勝手に高く見積もって、愚直に実装して AC することを目指さなかった
- gcd について
  - 小さい方の数（割る数を n として）計算量は O (log n)
    - 説明 1) ラメの定理により 最悪でも n の桁数 d の 5 倍で操作回数を抑えられるとすると
      n から桁数 d を求める操作(関数)を log10 n + 1 = O (log n) とできる　（ビッグオーの定義より）
    - 説明 2) b % (a%b) が b/2 以下になること利用して
      - 操作 2 回で 1/2 以下になるので、操作回数は 2 \* log2 b = O(log n)
      - 最悪でも 操作回数 k に対して n = 2^(k-1) が言えるので 操作回数は log2 2^(k-1) = O(log n) (ビッグオー記法の定義より)
      - b/2 以下になるのはなぜか？　直感的にはわかりにくい（証明は可能だが理解しにくい）
  - 参考
    - <https://blog.pixela.co.jp/2017/11/16/%E3%83%A6%E3%83%BC%E3%82%AF%E3%83%AA%E3%83%83%E3%83%89%E3%81%AE%E4%BA%92%E9%99%A4%E6%B3%95/>
    - <https://ja.wikipedia.org/wiki/%E3%83%A6%E3%83%BC%E3%82%AF%E3%83%AA%E3%83%83%E3%83%89%E3%81%AE%E4%BA%92%E9%99%A4%E6%B3%95#%E8%A8%88%E7%AE%97%E9%87%8F>
- 最大公約数について
  - 対象の数を構成する素数とその累乗を軸にとったとき、ある数 a, b で共有する領域の右上(最大の数)が最大公約数　（解説放送の 1:16:32 あたり）

d 問題

- 良かったこと
  - ひとまず実装したロジックは正しそう
- 改善したいこと
  - TLE を回避する方法が分からなかった。アルゴリズムの知識不足?
    - （解説を読んで）この問題については単なる考察不足だった
    - Not equal なら equal の場合を考えて、全体の集合から引けばいい
    - 条件が 2 つあったら、1 つだけを満たす場合を考える等、条件を変形・制限して考察する考え方が必要
    - O(N^3) に対して 2 変数から 3 変数目を導ければ O(N^2) にできるという考え方も足りてない

## ABC163

- b で提出言語選択ミス　かつ　変数名を間違えて分岐に設定していた
- c は内容理解が面倒で、整理したら簡単だった
- d は純粋に知識・経験不足。仕方ない、個数の mod を取る意味が理解できなかった
  - mod について
    - <https://ikatakos.com/pot/programming_algorithm/number_theory/mod_combination>
    - <https://drken1215.hatenablog.com/entry/2018/06/08/210000>
    - mint を定義しておくと楽らしい
      - <https://github.com/atcoder-live/library/blob/master/mint.cpp>

## ABC159

- a は string なので 全て共通であることを変に抽象化しないで、== "AAA" で良かった
- b は `n * a / (a+b)` でオーバーフローする、`a * (n/(a+b))` 等式変形して評価結果毎に注意？

### 解説放送

a

- pi は acos(-1) でいける

d

- 二項定理を活用するほどの問題ではなかった
- 任意の個数を選ぶ場合に、最小値と最大値から構成しうる和の個数を求められるという、整数の性質が自明じゃなかった

## ABC164

### 解説放送

- b
  - 愚直にシミュレーションしたが、実際には除算の結果を切り上げれば OK
    - (a + (b-1)) / b の結果を切り捨てれば a / b の結果の切り上げになる
      - <https://daeudaeu.com/programming/c-language/kurisuke_kiriage_shisyagonyu/>
      - 整数の割り算の結果の結果は、1/b 単位で変化し、小数部が 0 以外の場合に最小の値が 1/b だから b-1/b すれば必ず整数部が 1 上がる（繰り上がる）
    - なぜ ceil では駄目？ 浮動小数点の誤差が影響する可能性
    - ただの除算は結果を切り捨てすることを忘れない
- d
  - 累積和、逆元を知らないと無理
    - <https://qiita.com/drken/items/56a6b68edef8fc605821>
  - 整数 → 数列 → 累積和 → 累積和が 2019 の倍数＝ mod 2019 の場合に満たす関係式 → 累積和を順に調査（O(n)）

### 解説放送

- c
  - あらかじめ条件を満たした集合を定義しておいて、入力に応じて集合から外していく方針もあり
- d
  - 実際のところ、それなりに少ない候補を全探索すればよいだけだった
  - a, b の上限を調べることが必要
    - 素因数分解 →4 乗で X→X の最大値は 10^9 なので A は 最大でも 10^(2.5) くらい → B も同じくらいを調査

## ABC165

### 解説放送

a

- b 以下の最大の k の倍数は b/k \* k で求まる（なぜ？）

- c++ の vector はそのまま定義すると値渡し
  - 参照渡しの方が追加・削除を明示的に書く必要があるので分かりやすい... ように見えるがそうとも言えないかも

## ABC114

c

- 配列ではなく整数で DFS していく
  - 10x + 3, 10x + 7, ... の形で再帰関数の呼び出しを列挙するという発想
- 再帰の終了条件を整数で適宜設定しておく
- 全てが揃っているか等の判定はビットの論理和を使うと便利

## ABC167

c

- めちゃくちゃ時間かかったが、DFS で AC 出来たので満足
- 二次元配列への格納は `rep(j,m) cin >> a[i][j];` で良い

### 解説放送

a

- 入力の制約をきちんと読もう。英小文字しか来ない
- 文字列を削る操作は .pop_back() 可能

b

- なんか巧妙、オリジナル実装でなぜ駄目かよく分からない

c

- なぜか組み合わせの総数を 12 個から重複ありで 12 個選ぶ組み合わせの数として評価していた
  - 実際には選ぶ-選ばないの組み合わせだけ
  - 部分集合 => bit で ループ回す

### 解説放送

d

- 解法 1 循環を判定する
  - 到達頂点を記録し、同一の頂点に到達＝循環の発生とする
  - N 回遷移後の結果について、循環前の場合・循環後の場合に切り分けて判定を行う
- 解法 2 ダブリング
  - 各頂点について、1, 2, 4, 8... 回遷移先のテーブルを作成する
  - N 回遷移後の結果について、↑ のテーブルで既知の値の組み合わせで表現可能
  - 10^18 は 2 進数で何桁か？
    - 10^3 ~= 2^10 = 1024 なので、約 10 桁で換算すると、18/3 \*10= 60 桁あれば OK
- `ll d; 1 << D` はオーバフローするので `1ll<<D` と書かないといけない
- `int[1]` は `int[size]` なので size-1 個までしか参照できない
  - この場合の動作が Homebrew GCC 9.3.0 C++17 と GNU GCC 9.2.1 の AtCoder の実行環境で差異があるのかも？
    - というよりは AtCoder 上で実行されるテストケースによってあぶり出されているのかも
    - <https://atcoder.jp/contests/language-test-202001>

## ABC168

a, b

- かなりハイペースで AC

c

- double と int が混ざった四則演算の型ってどうなるんだっけ？
- 三角関数って C++ でどう使うんだっけ
- 教訓
  - 問題文をしっかり理解すること、各針が一定の角速度で動いている、としっかり書いている
  - 実装対象についてしっかりとイメージを持つこと、持てないなら画像検索でも動画でも何でも見る
  - pi = acos(-1) でおｋ
  - 精度指定なら printf が必要、cout は小数点以下 6 桁ぐらいで打ち止めになってしまう

### 解説放送

d

- 隣接リスト＝頂点に隣接する頂点の集合　で持つ
- BFS = while ループ内で queue に詰めていって処理、queue が空になったら終了が良い
- 各頂点の距離・親の頂点等の情報は素直に配列で持てばいい
- main 関数外（グローバルスコープ）で vector を宣言する場合はなぜ `vector<int> a[2]` の形じゃないと駄目なんだろう？
  - `vector<int>` 型の配列を宣言している模様
- queue のループの中で、親をベースに隣接リストから取り出した頂点に対して、距離・親の設定・queue への push を行う
- dist は -1 でも INF でもいいが、dist[0]=0 は宣言必要

### ABC159

c

- 相加相乗平均はすぐ思いついた、でも公式を見ても応用できると判断できなかった
  - 数学力が鈍っている気がする
- その後何となく整数が答えの方が数が大きくなるんだろうと仮定した、それは間違いだった
- 相加相乗平均の本質的な部分を理解しているかどうか、距離を互いに縮めると積が大きくなるという性質を分かっているか

d

- 何となく組み合わせを求める関数を書くのが無理だと思っていたが、別に nCk の k=2 で固定なら難しくもなんともない
- 計算量の見積もりはできていたようで出来ていなかった。ボールの数 \* ボールの種類の分布毎に組み合わせを計算すると、最悪 O(N^2)
- 2 重ループの計算量を抑えるためには、内側のループを、別の基準量から計算する等して回避する方法が良い
- 分布という形で配列を持つこと
  - a[i 番という種類]=j 個ある　のような形
- 分布と、i 番目に何の種類があるかという配列を混同しない

### ABC167 復習

d

- `vector<int> d[60];` は `d[0][2] == 2` のようにすると `segmantation error`
  - おそらく vector のサイズを指定していない状態が原因
  - これは素直に `int d[60][20005]` のようにしておけばよい
- ダブリングの表を作るのは、以下のどちらでも正しい
  - `d[i][j] = d[i-1][d[i-1][j]];`
  - `d[i+1][j] = d[i][d[i][j]]`
  - 最大桁（この問題では index 59）まで格納するようなループにすること
    - パターン 1 の場合は 終了条件は i<60 or i<=59
    - パターン 2 の場合は i<59 or i<=58
- `ll l = 1ll << i;` で２進数を得るテクニック
- 最大桁から `l <=k` する必然性は別にない？

### ABC157

c

- 全探索可能なら、変にスマートに求めようとするより安定しそう

d

- BFS
  - 良さそうだが、各頂点に対して BFS を適用すると計算量が O(N(N+M)) にならないか?
    - でもこの方針で、何かの問題を解いたことがある
- DFS

  - 到達可能だが、既に到達済みのものの扱いが?

- set に要素が含まれているかの判定は、`set.count` の方が boolean なので良い

### ABC169

b

- 10^18 は `1e18` とも書ける
- オーバーフローする可能性のある結果についてどう比較するか
  - 不等式を変形して、掛け算をなくす
- `mx/ans <a` (切り捨て)で 正しく `mx/ans <a` (切り捨てなし) を評価できるのか（必要十分なのか）
  - 切り捨てなしで不等式を満たす場合は、切り捨てありの不等式も満たす
  - その逆は成り立たなさそう、でも ↑ の性質でこのコードは十分？

c

- `ll temp = a * (b * 100+0.5);`
  - これは WA
  - a は ll 型だが、ll 型 \* double 型　のときに、double 型が ll 型にキャストされるわけではないみたい
    - 以下の説明でいくと、むしろ double 型に変換される
- `ll ib = (b * 100 + 0.5);`
  - 本当に 0.5 は必要なのか？　実際に提出してみると 1 ケースだけ通らない場合がある
  - しかし、小数第二位までしか与えられないのにどういう数を与えたら誤差が出るんだろう？
    - 9.79 -> 978 になる。
- double -> ll(int) のキャストは小数点以下は切り捨て
  - `ll temp = 0.1` のような代入もキャストが発生する
  - [型変換](http://www9.plala.or.jp/sgwr-t/c/sec04.html)

通常の算術変換

> そうでなく、いずれかの被演算子が long double の場合、他方の被演算子は long double に変換されます。
> そうでなく、いずれかの被演算子が double の場合、他方の被演算子は double に変換されます。
> そうでなく、いずれかの被演算子が float の場合、他方の被演算子は float に変換されます。

<https://ja.cppreference.com/w/cpp/language/operator_arithmetic#Conversions>

### ABC159

b

- どうやって回分を判定するか
  - for 文で末尾から判定する
  - reverse した結果が一致するか判定する

### ABC157

b

- 愚直に実装するのが 1 番
- pair でもいいし、独立した同じサイズの配列でもいい
- `{}` でスコープを切れると書きやすい場合もありそう

c

- `(int)(v[j])` で `string v` の要素を int 型にキャストできないっぽい
- `(char)(s[j])` で `vector<int>` の要素を char 型にキャストできないっぽい
- ある数値 `702` の桁を順に取り出したい場合は、`702 % 10` と `702 / 10` を繰り返してリストに詰めていく

### ABC156

b

- そのまま実装

c

- 範囲が限られているなら全探索が 1 番
- Σ のまま式展開するという発想も大事

### ABC155

c

- VSCode が C++17 の記法を使うとエラーを出す
- `map[xx]++` でカウントできる
- map の key は昇順に保たれるので iteration すると昇順に参照できる
- `for (auto p: map) {}` で iteration できる

### ABC154

b

- string は iteration できる
  - `for(char c : s)`

c

- "YES" と "Yes" を間違えない
- `vector` から重複要素を取り除く `a.erase(unique(a.begin(), a.end()), a.end())`

### ABC153

b

- どっちでも問題ないが、題材をきちんとシミュレーションすることを意識するなら 実際に H を減らしていく

c

- 降順ソートは`sort(h.begin(), h.end(), greater <>());`
- もしくは、sort してから a.pop_back() を 繰り返す
- `a.erase(a.begin()+i)` は O(n) なことに注意
  - <https://qiita.com/drken/items/18b3b3db5735241465ef>
- モンスターの数より必殺技を使える回数が多いケースの考慮漏れ、先入観に囚われないで制約の数式を見よう

### ABC152

b

- 特定の 1 文字で string を生成する `string(3, 'a')` のようにコンストラクタが使える
- int を char 型に変えたければ `'0'+1` のように書ける
- string の場合も昇順で小さい方を取得したければ `min(s, t)` で oK

c

- O(N^2) で、N=2\*10^5 はきつい、10^10 はアウトなので別の方針を考えた方がいい
- TLE 解決の鍵は、いかにループを省略するか、これまでの計算から分かっている情報を活用すれば可能になる
  - 今回は逐次比較しなくても、最小値さえ把握しておけば十分だった

### ABC151

b

- 簡単そうに見えても一応数式で書いてみるのが大事そう

c

- 問題をよく読む、ペナルティの定義の間違い

### 東京海上日動

a

- 文字の切り出しに substr が使えると便利

b

- int 型同士の積が 2^31-1 を超えると ll 型で扱われるかと思っていた
  - (ll)(a\*b) とかでも駄目、a, b それぞれを予め ll で取っておくか、(ll)a\*b で片方をキャストする
    - > 一方のオペランドが long long int 型を持つ場合、もう一方の演算子は long long int に変換されます。
    - <https://docs.oracle.com/cd/E19205-01/820-1209/bjabu/index.html>
  - 加算も同様
- ↑ を知らなかったので仕方ないとは思うが、疑って試してみることはできたはず
  - 提出しなくてもコード上で試せば分かることだった
- 結局は、ロジックは間違っていなかったが、最初の WA は B の位置関係を間違えていたために起きた
  - 直感に頼り切らないで場合分けする習慣を見に付けた方がいい気がする

c

- 愚直に試しても計算量的にきついという推測自体は当たっていた
- 累積和を使うテクニックは学んでいないのでこれは仕方ない
- vector は == で比較可能

- 累積和とは、ある数列aに対して、連続する区間の総和をとった数列s
  - s0 = 0
  - s1 = a0
  - s2 = a0 + a1
  - sn = a0 + a1 + ... an-1
- <https://qiita.com/drken/items/56a6b68edef8fc605821>

- いもす法は、区間の始点と終点（開区間・終点自身は区間に含めない）を1, -1 で表し、累積和をとることで区間の重なり状態を得る方法
  - 終点の配列のindex は実際の区間+1の地点になる
  - したがって、配列の長さは、累積和の元になっている数列の長さ+1が必要
  - 区間から累積和を得た後の末尾は不要なので pop_back
- <https://imoz.jp/algorithms/imos_method.html>

### ABC170

- 素数判定（試し割）が O(√n) になる理由が分からない
  - k が合成数なら必ず √k より小さい素因数を持つ ？
  - 逆に、n=pq, p > root n かつ q > root n なら n > pq となってしまうので、 q <= root n または p <= root n が成り立つ
  - どちらかが root n 以下であるということは、 root n で割り切れるので、試行は root n までで OK という理解になる
    - <https://cartman0.hatenablog.com/entry/2017/10/23/%E8%87%AA%E7%84%B6%E6%95%B0n%E3%81%8C%E2%88%9An%E4%BB%A5%E4%B8%8B%E3%81%AE%E3%81%99%E3%81%B9%E3%81%A6%E3%81%AE%E7%B4%A0%E6%95%B0%E3%81%A7%E5%89%B2%E3%82%8A%E5%88%87%E3%82%8C%E3%81%AA%E3%81%91%E3%82%8C>

- エラトステネスの篩